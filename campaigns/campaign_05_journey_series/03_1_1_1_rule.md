
### Main Quest Post 3: "The 1:1:1 Rule: One Design Doc Per Code File Per Test File"

**Target audience:** Developers using AI for code generation
**Length:** 2000-2500 words
**Channel:** r/elixir, dev.to, your blog

#### Content Outline

**Hook:**
- "After mapping stories to contexts, I still had a problem..."
- "AI generated code that worked but didn't match my mental model"
- "I discovered a simple pattern: document the design before generating code"

**The Problem:**
- AI generates working code with wrong architecture
- Hard to review AI-generated code for architectural fit
- No reference point for "is this right?"
- Tests generated from same flawed understanding

**The 1:1:1 Principle:**
```
Phoenix Convention: One test file per code file
Design-Driven Extension: One design document per code file per test file

docs/design/sessions/orchestrator.md          # Design document
lib/code_my_spec/sessions/orchestrator.ex     # Implementation
test/code_my_spec/sessions/orchestrator_test.exs # Tests
```

**Why This Works:**
- Design document = structured reasoning for AI
- Tests validate implementation matches design
- Traceability: design → code → tests
- Reference point when things don't work

**What Goes In a Design Document:**
```markdown
# Component: Sessions.Orchestrator

## Purpose
Coordinates multi-step coding sessions with approval gates

## Public API
- start_session(session_type, context) :: {:ok, Session.t()}
- advance_phase(session, input) :: {:ok, Session.t()} | {:error, reason}

## Dependencies
- Sessions.Repository
- Agents.Client
- Tasks.Context

## State Machine
:initializing → :gathering_context → :generating_design → ...

## Design Decisions
- Why GenServer: Need stateful process per session
- Why supervised: Sessions can crash and restart
- Why phases: Human approval gates between critical steps
```

**How I Write Design Docs:**
1. Start with purpose (one sentence)
2. Define public API (what other code calls)
3. List dependencies (what this calls)
4. Document key design decisions
5. Include state machines if relevant
6. Note error handling approach

**How I Use Them With AI:**
```
Prompt: "Here's the design document for Sessions.Orchestrator: [paste]
Generate the implementation following this design.
Ensure all public API functions are implemented.
Follow the state machine transitions exactly."
```

**The Test-Design Connection:**
- Tests validate design is implemented correctly
- When tests fail, compare to design (not guess)
- Design is the contract tests verify
- Update design if requirements change

**Comparison to No Design Docs:**

Without design:
- AI generates "working" code with questionable architecture
- Hard to review without reference
- Tests validate wrong behavior
- Technical debt accumulates silently

With design:
- AI generates code matching explicit architecture
- Easy to review (does it match design?)
- Tests validate design is met
- Changes require design updates (deliberate)

**Making It Practical:**
- Don't design everything upfront
- Design one component, implement, learn
- Refine design template as you go
- Some components need more detail than others
- Templates help (context design vs schema design)

**The Traceability Chain:**
```
User Story
    ↓
Context Mapping
    ↓
Component Design Document
    ↓
Implementation + Tests
    ↓
Working Code
```

**When Design Needs to Change:**
- Update design document first
- Regenerate implementation
- Tests fail = implementation doesn't match design
- Tests pass = design is implemented correctly

**Transition:**
- "This process works incredibly well but is tedious"
- "Write design, prompt AI, review, iterate"
- "I eventually automated the orchestration (see side quest)"

**Call to Action:**
- Pick one component to design
- Write design doc before prompting AI
- Generate implementation from design
- Compare quality to design-free approach
- Share your experience

**Side Quest Teaser:**
> I automated this entire workflow with session orchestration. Read about it here: [link to Side Quest 3A]

#### Source Material
- `/docs/resources/design_driven_code_generation.md` (simplified, focused version)
- Your actual design documents
- Before/after examples of AI output
- Phoenix conventions + design-driven extension

#### Success Metrics
- "This changed how I work with AI" comments
- Readers sharing their design doc formats
- Questions about specific design patterns
- Saved/bookmarked as reference
- Featured in ElixirWeekly
