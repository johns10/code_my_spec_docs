# Tag Schema

## Purpose

Ecto schema representing content tags for categorizing and organizing published content. Tags are single-tenant (no account_id/project_id scoping) and normalized to lowercase slugified format for consistency. Tags enable flexible content organization through many-to-many relationships with Content.

**Note**: This is the deployed client version. The CodeMySpec SaaS platform uses a separate ContentAdmin tag schema with multi-tenant scoping.

## Field Documentation

| Field | Type   | Required | Description                        | Constraints                |
| ----- | ------ | -------- | ---------------------------------- | -------------------------- |
| name  | string | yes      | Display name of the tag            | Length 1-50 characters     |
| slug  | string | yes      | URL-safe normalized identifier     | Lowercase, slugified, unique |

## Associations

### many_to_many
- **content** - Tags can be associated with multiple Content items through the ContentTag join table (content_tags)

## Validation Rules

### Name Validation
- Required field
- Minimum length: 1 character
- Maximum length: 50 characters

### Slug Validation
- Required field (passed in by caller, usually Content.upsert_tag/1)
- Normalized to lowercase
- URL-safe characters only (alphanumeric, hyphens)
- Unique across all tags (global uniqueness)

### No Multi-Tenancy
- No project_id or account_id fields
- Tags are shared across the entire deployed application
- Access control handled at Content level via protected flag

## Database Constraints

### Indexes
- Primary key on id
- Unique index on slug for fast lookups and uniqueness enforcement

### Unique Constraints
- Unique on slug - prevents duplicate tags globally

### Foreign Keys
- None - tags are standalone entities

## Business Rules

1. **Tag Normalization**: Tag slugs are generated by the Content context (Content.upsert_tag/1) which normalizes names to lowercase and slugifies
2. **Global Uniqueness**: Tag slugs must be unique globally across the application
3. **No Automatic Cleanup**: Tags are not automatically deleted when content is deleted (tags can be orphaned but reused)
4. **Case Insensitive**: Tag matching in upsert operations is case-insensitive since slugs are normalized
5. **No Multi-Tenant Isolation**: All content shares the same tag namespace - no scoping by account or project

## Usage Pattern

Tags are typically created via `Content.upsert_tag/1` which:
1. Generates slug from name using slugification
2. Checks if tag with that slug already exists
3. Returns existing tag if found, creates new tag if not

```elixir
# Create or find tag
{:ok, tag} = Content.upsert_tag("Elixir Programming")
# => %Tag{name: "elixir programming", slug: "elixir-programming"}

# Associate tags with content
{:ok, content} = Content.sync_content_tags(content, ["elixir", "phoenix", "liveview"])
```